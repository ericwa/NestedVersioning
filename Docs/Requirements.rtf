{\rtf1\ansi\ansicpg1252\cocoartf1138\cocoasubrtf230
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fmodern\fcharset0 Courier;\f2\fmodern\fcharset0 Courier-Bold;
\f3\fmodern\fcharset0 Courier-Oblique;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww10760\viewh13740\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\f0\b\fs24 \cf0 Requirements
\b0 \
\
1. create a photo montage, \'93copy\'94 drag in a vector graphic.\
	- vector graphic can be modified externally without affecting photo montage.\
	- photo montage can be branched and the graphic can be edited without affecting the original branch of the photo montage.\
	- vector graphic can be updated to the latest changes made outside the photo montage.\
\
2. page layout\
	- figures can be added by reference, to a specific branch of an object\
\
3. project containing 2 composite documents, which have embedded links to each other\
	- possible to create a totally independent copy of the project to use as a base for something else, and\
	the links between the 2 inner documents still work.\

\f1 \

\f0 4. QuArK-like project can be branched, tagged, and reverted, and contains inner documents which can be branched, tagged, reverted, undo/redo.\
\
5. switching branch is undoable. merge is undoable.\
\
6. same uuid = different versions of conceptually the \'93same thing\'94 (identity), different uuid = different thing (different identity). copy creates new identity.\
\
\

\b types of copy\
\
\pard\pardeftab720

\b0 \cf0 For an embedded object, I can think of two\
- return an independent copy of the embedded object, with no relabelling\
- return an independent copy of the embedded object, with relabelling every object to a new uuid and updating any references inside the copy which refer to old uuids to new uuids.\
\
For a persistent root, I can think of a lot more:\
- 
\i "copy history graph"
\i0 : return an independent copy of the entire history graph (like doing "cp -r some_git_repository new_copy". This is what I was thinking of doing in nested versioning -upon ever commit, all nested persistent roots inside an outer persistent root would be copied in this way.)\
- 
\i "create branch"
\i0 : create a new branch off of the current state of the persistent root, and return a link which tracks the latest version of the persistent root on the new branch (interestingly, this is the only one that performs a _mutable_ change to the persistent root)\
- "
\i non-versioned copy":
\i0  return a non-versioned (embedded object) copy of the current version of the persistent root, without any relabelling. \
- 
\i "non-versioned relabelled copy":
\i0  return a non-versioned (embedded object) copy of the current version of the persistent root, with relabelling every object to a new uuid and updating any references inside the copy which refer to old uuids to new uuids.\
- 
\i "link":
\i0  (not really copying) return a link to the persistent root which will continue to track further changes \'a0(i.e., just the persistent root's uuid)\
- "
\i link to version
\i0 ": (not really copying) return a link to the current version of the \'a0persistent root which will not track further changes (i.e. a string "uuid:version")\
- "
\i new persistent root"
\i0 : create a new persistent root with an empty history graph, and insert as its contents the "non-versioned relabelled copy"\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf0 \
\
\

\b Comments
\b0 \
\
- hope to express all copying behaviours with 2 ui labels: \'93link\'94 and \'93copy\'94\
	link: can be changed to copy.\
	copy: can be updated to a different version of the object, and changed to a link\
\
- duplicate is just a shortcut for copy & paste in same container.\
\
\
copy operation invariants:\
	for a copy C of a document D,\
		for a sub-document E of D which was inserted with \'93copy operation\'94:\
			C contains an E\'92 which can be modified without affecting E\
			E\'92 can be opened \
		for a sub-document F of D inserted with \'93link operation\'94:\
			the link in the copy points to the same place.\
\
commit vs user copy:\
\
what exactly is the difference between copy and link?\
	\'97 probably just metadata.\
\
\

\b design:\
\

\f1\b0 a commit contains a mapping of \{uuid => blob\}\
\
when an object is committed to, its parent needs to be updated without a commit\
\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\f2\b \cf0 problem with nested versioning:\
 - 
\f1\b0 branching a container should totally copy the history graph of the inner object\
\

\f2\b new design example:\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\f1\b0 \cf0 persistent roots:\
1. photomontage\
	contains copy of 2 at version A\
2. photo\
3. photolibrary\
	contains copy of 2 at version A\
\
** persistent roots can be in multiple states at the same time, \
   so they can be in multiple containers at once **\
\
scenarios:\
\
open 2 from within 3\
\
problem: we don\'92t want copies of template persistent roots to have the same uuid. (Suppose a root object is something like a template for a form letter, or a template for a resum\'e9, etc. When you make a copy of this, you want a new root object with a new UUID, since the final letter/resum\'e9 you produce should be a distinct object. In contrast, you might want to create branches of the template, to store slight variations on the template - like different font/color choices, different wordings for a form letter - and these would make sense as branches, and should share the same UUID with the basic template.)\
\
also need to be able to copy a template with embedded root objects and have copies of those made too.\
\
\
compare with unix filsystem:\
fs = \{ root = inode1; // will be a directory\
       inodetable = \{ inode : byte_array  // file inode\
                              | // or\
                              \{\'93string1\'94 : inode1; \'85\} // directory inode\
                    \}\
     \}\
\
copy a file has 2 steps:\
- create new inode with copy of byte array\
- insert a file somewhere in a directory linking to the new inode\
\
\
\
\
coreobject idea:\
2 namespaces: copies of same object are stored in the object history namespace (i.e. copies of a persistent root which don\'92t change the uuid, i.e. they\'92re braches).\
copies of the object which are new objects are given new uuids\'92, ie they\'92re new persistent roots.\
\
-make sure copy is properly transitive\
\
still not sure about \'93current branch\'94/\'93current version.\
\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\f2\b\fs30 \cf0 \'91relative reference\'92 requirement:
\f1\b0\fs24 \
\'93suppose B is embdedded in A.\
if a commit to B does not cause a synthetic commit in A,\
then A\'92s reference to B must be stored in such a way that it refers to the new version after this latest commit.\'94\
\
I hope the \'91relative reference\'92 requirement can be satisfied\'85 because we want all commits in a given persistent root to be semantically meaningful.\
\
	two possibilities for storing branch data:\
\
	( by branch data, I mean the pointer to the current version,\
	  and maybe auxiliary info for undo/redo - which direction\
	  redo should go in.)\
\
	1. branch data is kept at the site where it is embedded (i.e., in the versioned, \'93data\'94 namespace)\
		=> This will screw up undo. i.e. for a document embedded in a project, moving the \'91current version\'92 pointer of the inner document will cause commits in the project (non-semantically-meaningful commits?) -> then undo in the project will have to navigate over the commits which undo/redo changes in the inner document\
\
	2. branch data is kept in the history graph data structure (i.e., in the non-versioned, mutable \'93history\'94 namespace\'94) - but current branch is kept in the versioned contents\
\
\
\
Sounds like 2 is the way to go.\
\
\ul supposing we use design #2:\ulnone \
\
-suppose b is embedded in a\
=>create the branch data in the history graph, and create the pointer to the branch data (which branch) at the embedding site\
\
-to clone b (new uuid) => clone the documents embdedded in b. update the uudis where the sub-documents of b are embedded in b. history can be discareded.\
\
-to branch a, b and all other embedded root objects need to be branched also.\
\
\

\f2\b will accumulation of \'93garbage\'94 branches be a problem?
\f1\b0  well, if we\
-embed a peristent root (creating a branch)\
-delete it\
-undo\
-redo\
-embed it againg (creating another branch)\
\
should be ok.\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\f3\i \cf0 seems like we actually lose nothing without nested versioning.
\f1\i0  we can undo branch switch, since the current branch pointer is versioned. we can undo merge since it\'92s a normal commit. the history graph will just get a bit \'91overgrown\'92 after a while, but that\'92s necessary for undo, and we can always prune it.?\
\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\f2\b \cf0 can we get away without \'91default\'92 current branch? (this implies, \'93can we get away without \'91default\'92 current revision since current revision is stored in current branch)
\f1\b0 \
\
suppose we just store the current branch of the \'93root\'94 (\'91/\'91) persistent root. this lists the current branches of all contained objects, etc, etc, so in this way, we have defined the current branch and current revision of every object.\
\
\

\f2\b how will the object context api look with all of this?\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\f1\b0 \cf0 - the branch of embedded objects is determined by versionable data in the current editing context.\
\
seems like an object context should contain objects all from the same root object. it also needs to contain a reference to a version in that persistent root to base the changes on. 
\f2\b AND\'85 it needs to know what to update when it does a commit. i.e, what branch is it editing on. 
\f1\b0 \
\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\f2\b \cf0 with this new model, the side effect of taking a subtree of embedded objects and putting them in a new persistent root 
\f1\b0 is changes in the new persistent root no longer register undo actions in the old persistent root (but this is what we want - the defining property of persistent roots is that they are isolated from each other). However, the action of deleting the subtree and putting in an embedded reference can be undone as normal, leaving the new persistent root behind as garbage.}