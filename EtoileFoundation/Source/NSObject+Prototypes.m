#import "NSObject+Prototypes.h"
#import <objc/runtime.h>
// Prototypes are only supported with the GNUstep runtime currently.
#ifdef __GNUSTEP_RUNTIME__
#include <string.h>
#import <Foundation/Foundation.h>

struct objc_slot *objc_get_slot(Class cls, SEL selector);

/**
 * Name of a hidden class is generated by appending a number to this string.
 */
#define CLS_NAME_PREFIX "PrototypeHiddenClass#"
static BOOL isPrototypeClass(Class cls)
{
	return strncmp(CLS_NAME_PREFIX, class_getName(cls), strlen("PrototypeHiddenClass#")) == 0;
}

/**
 * The slots dictionary can not contain nil.  This is object used to implement
 * whiteout, so a nil inserted by one object will prevent it from accidentally
 * seeing its prototype's value.
 */
static id NULL_OBJECT_PLACEHOLDER;

/** 
 * A hidden class is a class with some other ivars for implementing properties.
 * This structure defines the ivars for the hidden class.
 */
typedef struct objc_hidden_class
{
	/** Reference count for this hidden class. */
	int refCount;
	/** Slots on this hidden class. */
	NSMutableDictionary *slots;
	/** Secondary lookup system. */
	NSMapTable *blockMethods;
	/** The prototype object. */
	id owner;
}* HiddenClass;

/**
 * This function is equivalent to -release, but for hidden classes.
 */
static void releaseHiddenClass(Class cls)
{
	Class super = class_getSuperclass(cls);
	HiddenClass hcls = object_getIndexedIvars(cls);
	// Decrement the reference count and free if it hits 0.
	// Note: __sync_fetch_and_sub returns the old value of the refcount.
	if (1 == __sync_fetch_and_sub(&hcls->refCount, 1))
	{
		// Free slot dictionary
		[hcls->slots release];
		NSFreeMapTable(hcls->blockMethods);
		objc_disposeClassPair(cls);
	}
	if (isPrototypeClass(super))
	{
		releaseHiddenClass(super);
	}
}

@protocol BlockClosure 
- (int32_t) argumentCount;
- value:a1;
- value:a1 value:a2;
- value:a1 value:a2 value:a3;
- value:a1 value:a2 value:a3 value:a4;
- value:a1 value:a2 value:a3 value:a4 value:a5;
@end

static id blockTrampoline(id self, SEL _cmd, ...);

@interface ETPrototypeTemplate
{
	id isa;
}
@end
@implementation ETPrototypeTemplate
+ (Class)class
{
	BOOL foundPrototype = NO;
	for (Class cls = self ; Nil!=cls ; cls=class_getSuperclass(cls))
	{
		// Find a hidden class
		if (isPrototypeClass(cls))
		{
			foundPrototype = YES;
		}
		else
		{
			if (foundPrototype)
			{
				return cls;
			}
		}
	}
	return nil;
}
- (Class)class
{
	return [object_getClass(self) class];
}
- (Class)prototypeClass
{
	for (Class cls = object_getClass(self) ; Nil!=cls ; cls=class_getSuperclass(cls))
	{
		// Find a hidden class
		if (isPrototypeClass(cls))
		{
			HiddenClass hcls = object_getIndexedIvars(cls);
			if (hcls->owner == self)
			{
				return cls;
			}
		}
	}
	return nil;
}
- (BOOL)isPrototype
{
	return YES;
}
/**
 * Implementation of setValue:forUndefinedKey: for hidden classes.
 */
- (void)setValue: value forUndefinedKey: (NSString*)key
{
	value = [[value retain] autorelease];
	id block = NULL_OBJECT_PLACEHOLDER;
	Class blockClass = objc_lookUpClass("BlockClosure");
	SEL sel;
	if ([value isKindOfClass: blockClass])
	{
		// The method takes one fewer arg than the block.
		// Note: We allow blocks with fewer args than we really want for
		// EScript - it's not sensible to use them in Smalltalk.
		switch ([value argumentCount])
		{
			default:
				return;
			case 0:
				sel = @selector(value);
				break;
			case 1:
				sel = @selector(value:);
				break;
			case 2:
				sel = @selector(value:);
				break;
			case 3:
				sel = @selector(value:value:);
				break;
			case 4:
				sel = @selector(value:value:value:);
				break;
			case 5:
				sel = @selector(value:value:value:value:);
				break;
			case 6:
				sel = @selector(value:value:value:value:value:);
				break;
		}
		struct objc_slot *s = objc_get_slot([value class], sel);
		sel = sel_registerTypedName_np([key UTF8String], s->types);
		[(NSObject*)self setMethod: blockTrampoline forSelector: sel];
		block = value;
	}
	else
	{
		sel = sel_getUid([key UTF8String]);
	}
	HiddenClass hcls = object_getIndexedIvars([self prototypeClass]);


	NSMapInsert(hcls->blockMethods, sel_getName(sel), block);
	if (value == nil)
	{
		value = NULL_OBJECT_PLACEHOLDER;
	}
	[hcls->slots setObject: value forKey: key];
}

/**
 * Implementation of valueForUndefinedKey: for hidden classes.
 */
- valueForUndefinedKey: (NSString*)aKey
{
	HiddenClass hcls = object_getIndexedIvars([self prototypeClass]);
	id value = [hcls->slots objectForKey: aKey];

	if (value == NULL_OBJECT_PLACEHOLDER)
	{
		value = nil;
	}

	return value;
}

/**
 * Implementation of allocWithZone: for hidde classes.
 */
+ allocWithZone: (NSZone*)aZone
{
	return [[self class] allocWithZone: aZone];
}
/**
 * Implementation of dealloc for hidden classes.  Decrements the reference
 * count for the hidden class.
 */
- (void)dealloc
{
	Class hcls = [self prototypeClass];
	Class class = [self class];
	struct objc_super s = {self, class};
	// Send [super dealloc] to the first non-hidden class
	objc_msg_lookup_super(&s, _cmd)(self, _cmd);
	// Self is invalid after this point.
	self = nil;
	// Decrement the reference count of every hidden class in the chain
	releaseHiddenClass(hcls);
}
@end

static void copyAllMethods(Class from, Class to)
{
	unsigned int methodCount;
	Method *methods = class_copyMethodList(from, &methodCount);
	for (Method *m = methods ; NULL!=*m ; m++)
	{
		class_addMethod(to, method_getName(*m),
			method_getImplementation(*m), method_getTypeEncoding(*m));
	}
	free(methods);
}
/**
 * Perform a hidden class transform if this object is not already a prototype.
 */

static Class hiddenClassTransform(id obj)
{
	Class isa = object_getClass(obj);
	for (Class cls = isa ; Nil!=cls ; cls=class_getSuperclass(cls))
	{
		// Find a hidden class
		if (isPrototypeClass(cls))
		{
			HiddenClass hcls = object_getIndexedIvars(cls);
			if (hcls->owner == obj)
			{
				return cls;
			}
		}
	}
	// Set the isa pointer to a hidden class inheriting from this one.
	static unsigned int count;
	// FIXME: Should be atomic increment
	char *name;
	asprintf(&name, "%s%d", "PrototypeHiddenClass#", count++);
	Class hidden = 
		objc_allocateClassPair(isa, name, sizeof(struct objc_hidden_class));
	Class template = objc_lookUpClass("ETPrototypeTemplate");
	// Copy the methods from the template
	copyAllMethods(template, hidden);
	copyAllMethods(object_getClass(template), object_getClass(hidden));
	objc_registerClassPair(hidden);
	HiddenClass hcls = object_getIndexedIvars(hidden);
	hcls->refCount = 1;
	// Create the slots 
	hcls->slots = [NSMutableDictionary new];
	hcls->blockMethods = NSCreateMapTable(NSNonOwnedPointerMapKeyCallBacks,
			NSObjectMapValueCallBacks, 5);

	// Not retained, or there would be a cycle
	hcls->owner = obj;
	obj->isa = hidden;
	return hidden;
}

static id blockTrampoline(id self, SEL _cmd, ...)
{
	id block = nil;
	for (Class cls = object_getClass(self) ; Nil!=cls ; cls=class_getSuperclass(cls))
	{
		// Find a hidden class
		if (isPrototypeClass(cls))
		{
			HiddenClass hcls = object_getIndexedIvars(cls);
			block = NSMapGet(hcls->blockMethods, sel_getName(_cmd));
			if (nil != block)
			{
				break;
			}
		}
	}
	if (block == nil || block == NULL_OBJECT_PLACEHOLDER)
	{
		return [self valueForUndefinedKey: NSStringFromSelector(_cmd)];
	}
	va_list ap;
	switch ([block argumentCount])
	{
		default:
			[NSException raise:NSInvalidArgumentException
			            format:@"Incorrect number of arguments"];
		case 0:
			return [block value];
		case 1:
			return [block value: self];
		case 2:
		{
			va_start(ap, _cmd);
			id arg1 = va_arg(ap, id);
			va_end(ap);
			return [block value: self value: arg1];
		}
		case 3:
		{
			va_start(ap, _cmd);
			id arg1 = va_arg(ap, id);
			id arg2 = va_arg(ap, id);
			va_end(ap);
			return [block value: self value: arg1 value: arg2];
		}
		case 4:
		{
			va_start(ap, _cmd);
			id arg1 = va_arg(ap, id);
			id arg2 = va_arg(ap, id);
			id arg3 = va_arg(ap, id);
			va_end(ap);
			return [block value: self value: arg1 value: arg2 value: arg3];
		}
		case 5:
		{
			va_start(ap, _cmd);
			id arg1 = va_arg(ap, id);
			id arg2 = va_arg(ap, id);
			id arg3 = va_arg(ap, id);
			id arg4 = va_arg(ap, id);
			va_end(ap);
			return [block value: self
			              value: arg1
			              value: arg2
			              value: arg3
			              value: arg4];
		}
	}
	return [block value];
}

@implementation NSObject (Prototypes)
- (void)setMethod: (IMP)aMethod forSelector: (SEL)aSelector
{
	// Ensure that this object has a hidden class
	class_addMethod(hiddenClassTransform(self), aSelector, aMethod,
			sel_getType_np(aSelector));
}
- (id) cloneWithZone: (NSZone *)zone
{
	id obj = [(id)self copyWithZone: zone];
	hiddenClassTransform(obj);
	return [obj autorelease];
}
- (id) clone
{
	return [(id)self cloneWithZone: NSDefaultMallocZone()];
}
- (BOOL) isPrototype
{
	return NO;
}
- (id) prototype
{
	return nil;
}
- (void) becomePrototype
{
	hiddenClassTransform(self);
}
- (id) slotValueForKey:(NSString *)aKey
{
	id value = nil;
	/*
	for (Class cls=isa; value == nil && CLS_ISHIDDEN(cls); cls=cls->super_class)
	{
		value = [(((HiddenClass)cls)->slots) objectForKey:aKey];
	}
	if (value == nil)
	{
		return [self valueForKey:aKey];
	}
	if (value == NULL_OBJECT_PLACEHOLDER)
	{
		return nil;
	}
	*/
	return value;
}
@end
#endif
