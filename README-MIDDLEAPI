The middle API has no knowledge of COObject/COObjectContext.

What does it do?

Maintains the history graph.


Commits across two stores... how does that work?


1) no synchronization possible - history graph can't cross store boundaries.
-> we couldn't do copies from one store to another.

how should stores work w.r.t. removable media? Just like a git repository.


Every user operation goes into a persistent log.
Undo tracks.

Not all commits should result in undo log.
e.g. a download finishing. Things not the result of user actions.

permanently deleting something:
 needs to be possible.
 needs to rewite history?
 
don't rewrite any history.



History compression: can we do it?


a-b-c-d-e-f-g-h-i-j

..

    /-D-E-F-G-H-I-J
a-b-c-d-e-f-g-h-i-j

..

    /-D-E-F-G-H-I-J
a-----------------j


If we delete all metadata except parent changeset pointers, we don't break
branches.




History DB schema..


table Parents ([key changeset UUID 


Branching approach: 

- create a named branch.
- 


Undo manager approach:

- any things we want to be able to undo are tracked by CO. 
what about things that require bookkeeping?




